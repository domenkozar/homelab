diff --git a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_dpia.c b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_dpia.c
index 603537ffd128..c61d0affad78 100644
--- a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_dpia.c
+++ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_dpia.c
@@ -991,20 +991,33 @@ enum link_training_result dpia_perform_link_training(
 	const struct dc_link_settings *link_setting,
 	bool skip_video_pattern)
 {
-	enum link_training_result result;
+	enum link_training_result result = LINK_TRAINING_ABORT;
 	struct link_training_settings lt_settings = {0};
-	uint8_t repeater_cnt = 0; /* Number of hops/repeaters in display path. */
-	int8_t repeater_id; /* Current hop. */
+	uint8_t repeater_cnt = 0;
+	int8_t repeater_id;
+	bool retry_post_lt_link_loss = true;
+	bool retry_without_lttpr = false;
+	bool force_non_lttpr = false;
 
-	struct dc_link_settings link_settings = *link_setting; // non-const copy to pass in
+	struct dc_link_settings link_settings = *link_setting;
 
-	lt_settings.lttpr_mode = dp_decide_lttpr_mode(link, &link_settings);
+
+training_retry:
+	/*
+	 * Keep LTTPR override local to this attempt.
+	 * Avoid mutating global dc->debug policy in runtime recovery code.
+	 */
+	lt_settings.lttpr_mode = force_non_lttpr ?
+		LTTPR_MODE_NON_LTTPR :
+		dp_decide_lttpr_mode(link, &link_settings);
 
 	/* Configure link as prescribed in link_setting and set LTTPR mode. */
 	result = dpia_configure_link(link, link_res, link_setting, &lt_settings);
 	if (result != LINK_TRAINING_SUCCESS)
 		return result;
 
+	repeater_cnt = 0;
+
 	if (lt_settings.lttpr_mode == LTTPR_MODE_NON_TRANSPARENT)
 		repeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);
 
@@ -1037,9 +1050,29 @@ enum link_training_result dpia_perform_link_training(
 		fsleep(5000);
 		if (!link->skip_fallback_on_link_loss)
 			result = dp_check_link_loss_status(link, &lt_settings);
+
+		if (result == LINK_TRAINING_LINK_LOSS && retry_post_lt_link_loss) {
+			retry_post_lt_link_loss = false;
+			DC_LOG_HW_LINK_TRAINING(
+				"%s: retry link training once at same rate after post-LT link loss\n",
+				__func__);
+			goto training_retry;
+		}
+
+		if (result == LINK_TRAINING_LINK_LOSS &&
+		    !retry_without_lttpr &&
+		    lt_settings.lttpr_mode == LTTPR_MODE_NON_TRANSPARENT &&
+		    repeater_cnt > 0) {
+			retry_without_lttpr = true;
+			force_non_lttpr = true;
+			DC_LOG_HW_LINK_TRAINING(
+				"%s: retry link training in non-LTTPR mode after LTTPR link loss\n",
+				__func__);
+			goto training_retry;
+		}
 	} else if (result == LINK_TRAINING_ABORT)
 		dpia_training_abort(link, &lt_settings, repeater_id);
-	else
+	else if (result != LINK_TRAINING_LINK_LOSS)
 		dpia_training_end(link, &lt_settings, repeater_id);
 
 	return result;
